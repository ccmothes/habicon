---
output: github_document
always_allow_html: true
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# **habicon**

<!-- badges: start -->
<!-- badges: end -->

The goal of `habicon` is to calculate habitat patch and corridor priority in terms of their degree of importance to ecological connectivity. It is designed to integrate habitat suitability data (e.g., outputs of species distribution models) and connectivity/corridor data (e.g., outputs from connectivity models such as CIRCUITSCAPE)


You can install the development version of `habicon` on GitHub with:

``` r
devtools::install_github("ccmothes/habicon")
```

## Example

This is a basic example using simulated habitat suitability and connectivity maps demonstrating the functions available so far. 

**NOTE: This package is still in the early stages of development and more functions with increased user flexibility are coming soon!**

```{r example, message=FALSE, warning=FALSE}
library(habicon)
```

First let's visualize the simulated raster maps included as example data.

These include **suit** where values represent habitat suitability and range from 0-1 (1 being high suitability):
```{r suit}
plot(suit)
```
 
And second **corr** where values represent conductance to movement and range from 0-10 (10 being high conductance/ease of movement):
```{r corr}
plot(corr)
```

## Prep Functions


## Create binary maps to identify individual habitat patches and corridors using the `bin_map` function

Other inputs needed for the priority calculations are binary maps, which can be created using the `bin_map` function. 

Users can test and view binary maps over a range of values:
```{r binmap}
suit_bin <- bin_map(suit, threshold = c(0.4, 0.6, 0.8))
plot(suit_bin)
```

Often species distribution models calculate potential threshold values that users can choose to use. Or, say you want to identify patches of the highest habitat suitability, say the top 20% of suitability values:
```{r}
suit_bin <- bin_map(suit, threshold = quantile(values(suit), 0.8))
plot(suit_bin)
```

For this example, let's stick with the top 20% of suitability and conductance values to make the binary maps that identify the individual habitat patches and corridors.

```{r}
corr_bin <- bin_map(corr, threshold = quantile(values(corr), 0.8))
plot(corr_bin)
```

## Calculate patch priority with the `patch_priority` function
This function ranks individual patches based on multiple connectivity metrics, including quality-weighted area, weighted betweenness centrality, and dEC (see Saura et al. 2011). Higher values indicate higher importance for all metrics. This function returns a raster layer for each metric, with a connectivity importance value assigned to each patch. It also returns a sumamry table of all metric scores for each patch. For this example I kept the default minimum area (removes patches that are just one pixel) and set the medium dispersal distance (d) to 100. Note that this function takes distances in meters. The minimum area argument works on vectors of two numbers (since working with pixels), so if applying your own minimum area you must enter, for example, min_area = c(10,10) or min_area = 2*res(suit), since 'res' returns a vector of two numbers.  

```{r eval = FALSE}
library(scales)
patch_prior <- patch_priority(suit = suit, suit_bin = suit_bin)
plot(patch_prior, col = gradient_n_pal(brewer_pal("seq")(9))(seq(0, 1, length=100)), 
     main = "Patch Priority")
```


## Calculate corridor priority with the `corr_priority` function

Now using our continuous and binary habitat and corridor surfaces, we can calculate corridor priority with the `corr_priority` function.
NOTE: This function may take a while, as it performs many calculations on each individual cell. I am working on speeding up the run time.
```{r eval=FALSE}
corr_prior <- corr_priority(suit = suit, suit_bin = suit_bin, corr = corr_rescale, corr_bin = corr_matrix)
```
```{r message = FALSE}
library(viridis)
plot(corr_prior, col = inferno(n = 100), main = "Corridor Priority")
```




## Final Product:
```{r echo = FALSE}

plot(corr_prior, col = inferno(n = 100), legend = FALSE, axes = FALSE)
plot(corr_prior, legend.only = TRUE, col = inferno(100), horizontal = TRUE,
       smallplot = c(0.1,0.4,0.1,0.12),
     legend.width = 0.25,
     legend.shrink = 0.5,
     axis.args = list(
                      las = 2,
                     
                      cex.axis = 0.8,
                      mgp = c(5,0.3,0)),
     legend.args = list(text = "Corridor Priority", 
                      side = 3, 
                      font = 2, 
                      line = 0.5, 
                      cex = 1))
plot(patch_prior, col = gradient_n_pal(brewer_pal("seq")(9))(seq(0, 1, length=100)), legend = FALSE, axes = FALSE, add = TRUE)
plot(patch_prior, legend.only = TRUE, col = gradient_n_pal(brewer_pal("seq")(9))(seq(0, 1, length=100)), horizontal = TRUE, smallplot = c(0.5,0.8,0.1,0.12),
     legend.width = 0.25,
     legend.shrink = 0.5,
     axis.args = list(
                      las = 2,
                     
                      cex.axis = 0.8,
                      mgp = c(5,0.3,0)),
     legend.args = list(text = "Patch Priority", 
                      side = 3, 
                      font = 2, 
                      line = 0.5, 
                      cex = 1))
```

### `habicon` is still in the early stages of development, but hopefully this was a good teaser of what is to come. Stay tuned!
